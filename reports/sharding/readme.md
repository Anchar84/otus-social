# Отчет по домашнему заданию шардирование.

### Архитектура и алгоритмы работы с шардами

Реализован отдельный сервис диалогов пользователей. Хранение диалогов распределено по шардам.

Сущность диалог имеет следующие поля:
- fromUserId - идентификатор автора сообщения
- toUserId - идентификатор получателя сообщения
- text - само сообщение
- createdAt - дата и время сохранения сообщения
- shadr_key - ключ шардирования, является строко, созданной по шаблону $fromUserId_$toUserId

Для шардирования использовался инструмент citus, ключ шардирования специально состоит из идентификатора отправителья и получателя,
чтобы избежать "эффекта Леди Гаги". Таким образом, если один пользователь ведет очень интенсивную переписку с большим количеством других
пользователей его диалоги будут распределены по разным шардам.
При этом становиться сложнее получить список всех диалогов пользователя. На данный момент такой задачи не стоит, однака если бы она
появилась можно было бы использовать дополнительную таблицу с ключем шардирования только по идентификатору пользователя, в которой можно
хранить идентификаторы пользователей, с которыми данный пользователь ведет диалоги. Таким образом, получение текстов всех диалогов можно 
будет реализовать в два шага 
- сначала из одного шарда по идентификатору пользователя получить идентификаторы список идентификаторов пользователей с которым он переписывается
- составить по полученному списку пары ключей $fromUserId_$toUserId с помощью которых получить тексты. При этом, так как в запрос будет использоваться
ключь шардирования, будут задейстованы не все шарды, а только целевые

### решардинг
Согласно документации citus (https://docs.citusdata.com/en/stable/admin_guide/cluster_management.html), для решардинга можно использовать следующие функции:
- citus_add_node - для добавления worker
- citus_rebalance_start - для запуска процесса перераспределения данных между шардами с учетом нового worker, при этом начиная с 11 версии citus поддерживает переносить данные без блокировки на запись и чтенье 

### стек технологий и модулей
- модуль пользователей - хранит информацию о пользователях, отвечает за авторизацию
- модуль постов - хранит посты и информацию по подписках
- модуль диалогов - хранит диалоги между пользователями
- postgres - содержит две реляционные базы для модулей пользователей и постов
- rabbitmq - брокер сообщений, используется для асинхронного запуска формирование кеша ленты постов (для каждого подписчика отдельное событие)
- redis - кеш ленты постов
- citus - используется для шардирования диалогов пользователей

для авторизации пользовательских запросов используется jwt, то есть чтобы выполнить запрос необходимо сначала 
авторизоваться в модуле пользователей (при успешной авторизации возвращается токен) и далее полученный токен добавлять во все 
запросы в заголовок **X-Auth**

Запросы можно посмотреть в постман коллекции _postman_collection.json_ (запросы POST /dialog/{recipientId}/send и GET /dialog/{recipientId}/list)
Для запуска проекта можно использовать _docker-compose.yml_, например командой _docker-compose -p otus-social up --scale worker=2_
